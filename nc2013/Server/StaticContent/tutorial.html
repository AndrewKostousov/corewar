<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" ng-app>
<head>
	<meta charset="utf-8" />
	<title>Core War Arena</title>
	<script src="jquery-1.7.2.min.js"></script>
	<script src="angular.min.js"></script>
	<script src="bootstrap.min.js"></script>
	<link rel="stylesheet" href="bootstrap/bootstrap.css" />
	<script src="common.js"></script>
	<script src="server.js"></script>
	<style>
    .text {
      font-size: 11pt;
    }

    .text div, div.code { 
      margin-top: 15px;
    }

    div.code + .code {
      margin-top: 0px;
    }

    div.code {
      font-size: 12pt;
      border-left: 2px solid #CCC;
      padding-left: 12px;
    }

    .code, .command, .addr {
      font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
      white-space: nowrap;
    }

    .command, .addr {      
    }

    .command {
      color: #050;
      font-weight: bold;
    }

    .addr {
      color: #900;
    }

    .hint {
      border-bottom : 1px dashed #666;
    }

    div.todo {
      color: #777;
    }
	</style>
	<link rel="stylesheet" href="common.css" />
</head>
<body>
	<div class="container">

		<script>nav()</script>

    <div class="text">

		<div class="page-header">
			<h1>Core War для чайников</h1>		
    </div>

    <div>
      Сегодня нас ждут сражения. Полем битвы выбрана память компьютера, а бойцами &mdash; программы, которые вы напишете.
      В каждом раунде турнира будут сражаться две из них, а победит сильнейшая!
    </div>

    <h3 id="rules">Правила</h3>
    <div>
      Возможно, вы слышали о таком соревновании как <a href="http://en.wikipedia.org/wiki/Core_War">Core War</a> (Бои в памяти).
      Мы взяли за основу правила <a href="http://corewar.co.uk/icws88.txt">Core War 88-ого года</a>, однако не обошлось без&nbsp;<a href="#distinction">серьёзных <a href="#command-spl">изменений</a>. Пожалуйста, внимательно прочтите нижепредставленную документацию. 
      В случае разночтений в этих и оригинальных правилах следовать нужно ниженаписанному.
    </div>

    <h3 id="memory">Память</h3>
    <div>
      Память нашего компьютера состоит из <b>ячеек</b>, а именно из <b>8000</b> ячеек.
      Она зациклена таким образом, что после последней ячейки идет первая (а соответственно перед первой &mdash; последняя).
      Мы пронумеровали все ячейки номерами от 0 до 7999. Каждая из них содержит ровно одну инструкцию, более того &mdash;
      в памяти нашего компьютера хранятся только инструкции и ничего кроме инструкций.
    </div>

    <div>
      У каждой инструкции есть один или два операнда.
      Чаще всего они указывают на адрес ячейки или ячеек, над которыми нужно провести операцию.
      Обратите внимание &mdash; вы никогда не можете обратиться к ячейке по абсолютному адресу,
      вы можете только указать её относительное смещение относительно текущей.
      Из этого следует, что вы никогда не сможете узнать абсолютный адрес какой бы то ни было ячейки.
    </div>

    <div>
      Язык, изпользуемый в Core War, очень похож на ассемблеры, в нём присутствуют условные и безусловные переходы, копирование, сложение и вычитание.
      Рассмотрим пример простейшей программы, состоящей из одной команды:
    </div>

    <div class="code">
      <span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$1</span></span>
    </div>

    <div>
      Первым делом здесь записано <b>название команды (<span class="command">MOV</span>)</b>,
      после чего через запятую указаны два его <b>операнда</b> (или <b>аргумента</b>).
      Первый операнд так же называется <b><span class="hint" title="A-field">А-полем</span></b>, а второй &mdash; <b><span class="hint" title="B-field">В-полем</span></b>.
    </div>

    <div>
      Команда <span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$1</span></span>,
      как понятно из ее названия, скопирует содержимое ячейки, лежащей по адресу <span class="addr">$0</span>,
      в ячейку по адресу <span class="addr">$1</span>. Давайте разберёмся, что означают адреса со знаком доллара.
      Запись <span class="addr">$N</span> указывает на ячейку,
      находящуюся на позиции через <span class="addr">N</span> после текущей.
      Таким образом, <span class="addr">$1</span> указывает на следующую ячейку,
      а <span class="addr">$5</span> &mdash; на ячейку через четыре.
      Однако число <span class="addr">N</span> вовсе не обязано быть положительным (хотя, конечно, должно быть целым),
      например <span class="addr">$-1</span> указывает на предшествующую ячейку, а <span class="addr">$0</span>
      &mdash; на непосредственно исполняемую.
    </div>

    <div>
      Теперь мы понимаем, что команда <span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$1</span></span>
      скопирует содержимое текущей ячейки памяти (то есть саму себя) в следующую ячейку.
      Что же произойдет дальше? А дальше, как и в большинстве других языков программирования,
      исполнение перейдет к следующей инструкции, то есть к инструкции, лежащей в следующей ячейке памяти.
      Так как мы туда только что скопировали инструкцию <span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$1</span></span>,
      то выполняться будет именно она. Эта инструкция сделает то же самое, что и первая
      &mdash; скопирует себя в следующую ячейку, в которую затем передастся выполнение.
      Таким образом, эта программа (которая так же называется <i>Imp</i>) заполняет своей программой всю память, двигаясь вперед на одну ячейку каждый такт.
    </div>

    <h3 id="dat">Смерть</h3>
    <div>
      Однако всё было бы слишком хорошо, если бы программы могли только копировать ячейки и ничего не угрожало бы их существованию.
    </div>

    <div>
      Рассмотрим другую команду &mdash; <span class="command">DAT</span>.
      Она имеет сразу два назначения: во-первых, в ее операндах можно хранить данные &mdash; произвольные неотрицательные целые числа,
      меньшие 8000, а во-вторых, программа, выполнившая команду <span class="command">DAT</span> (неважно, с какими аргументами),
      моментально умирает и прекращает свое дальнейшее выполнение.
    </div>

    <div>      
      Сразу становится понятна главная цель любой программы &mdash; необходимо заставить противника наткнуться на команду <span class="command">DAT</span>
      и выполнить её. Один из очевидных способов это сделать &mdash; пытаться &laquo;разбрасывать&raquo; команды <span class="command">DAT</span> по всему полю.
    </div>

    <div>
      Именно такой стратегии придерживается <i>Бомбер</i>, который каждые несколько тактов &laquo;бросает&raquo; команду <span class="command">DAT</span>
      в какую-то ячейку памяти:
    </div>

    <div class="code"><span class="command">ADD</span> <span class="addr">#4</span>, <span class="addr">$3</span></div>
    <div class="code"><span class="command">MOV</span> <span class="addr">$2</span>, <span class="addr">@2</span></div>
    <div class="code"><span class="command">JMP</span> <span class="addr">$-2</span></div>
    <div class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#0</span></div>

    <div>
		В самом начале, еще до исполнения любых команд, программа размещается в случайной последовательной области памяти. 
		В случае боя двух программ, они размещаются в случайных непересекающихся областях на расстоянии друг от друга не менее, чем 1024 ячеек. 
		В любую незанятую какой-либо программой ячейку записывается команда <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#0</span></span>.
    </div>

    <h3 id="addressing">Адресация</h3>

    <div>
      Мы видим, что в <i>Бомбере</i> появились символы перед операндами, отличные от знака доллара:
      <ul>
        <li id="addressing-direct">
          Запись <span class="addr">$N</span>, которую мы уже видели ранее, называется <b><span class="hint" title="Direct">прямой</span></b> адресацией.
        </li>
        <li id="addressing-immediate">
          Запись <span class="addr">#N</span> означает <b><span class="hint" title="Immediate">непосредственную</span></b> адресацию, то есть она не указывает на какую бы то ни было ячейку в памяти, она показывает, что операндом является число N.
        </li>
    		<li id="addressing-indirect">
    			Запись <span class="addr">@N</span> называется <b><span class="hint" title="Indirect">косвенной</span></b> адресацией.
          Значение&nbsp;<span class="addr">N</span> используется как относительно смещение для поиска некоторой ячейки, обозначим её как&nbsp;<span class="addr">X</span>.
          После этого В-поле ячейки <span class="addr">X</span> используется как смещение относительно ячейки&nbsp;<span class="addr">X</span> &mdash; на эту ячейку и будет указывать запись <span class="addr">@N</span>.
    		</li>
        <li id="addressing-predecrement-indirect">
          Кроме того, существует четвёртый тип адресации, <b><span class="hint" title="Pre-decrement indirect">предекрементный косвенный</span></b>. Он записывается как <span class="addr">&lt;N</span> и означает следующее: значение&nbsp;<span class="addr">N</span> используется как относительно смещение для поиска некоторой ячейки, обозначим её как&nbsp;<span class="addr">X</span>.
          После этого В-поле ячейки <span class="addr">X</span> уменьшается на единицу и записывается в то же В-поле, где оно было взято. Затем это новое значение В-поля используется как смещение относительно ячейки&nbsp;<span class="addr">X</span> &mdash; на эту ячейку и будет указывать запись&nbsp;<span class="addr">&lt;N</span>.
        </li>
	   </ul>		
    </div>

    <div>
      Знак доллара (прямой адресации) можно опускать и не писать, то есть вместо
      <span class="code"><span class="command">ADD</span> <span class="addr">#4</span>, <span class="addr">$3</span></span>
      можно написать
      <span class="code"><span class="command">ADD</span> <span class="addr">#4</span>, <span class="addr">3</span></span>.

      Не все виды адресации допустимо использовать с теми или иными командами. Список допустимых адресаций указан в разделе 
      &laquo;<a href="#addresses">Возможные адресации всех команд</a>&raquo;. В случае использования недопустимых адресаций возникает ошибка компиляции <a href="#error-invalid-addressing-mode">Invalid addressing mode</a>.

    </div>


    <div>
      Давайте подробнее рассмотрим алгоритм <i>Бомбера</i>.
      Выполнение программы, если не указано иное, начинается с её первой инструкции, в данном случае
      с&nbsp;<span class="code"><span class="command">ADD</span> <span class="addr">#4</span>, <span class="addr">$3</span></span>,
      которая прибавляет число 4 к инструкции <span class="addr">$3</span>.
      Прибавление числа к инструкции ведет к увеличению В-поля указанной инструкции, в данном случае команда превратит <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#0</span></span>
      в&nbsp;<span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></span>.
    </div>

    <div>
      Следующая команда, <span class="code"><span class="command">MOV</span> <span class="addr">$2</span>, <span class="addr">@2</span></span>,
      как мы уже знаем, копирует содержимое ячейки <span class="addr">$2</span>
      (в текущий момент это <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></span>)
      в ячейку <span class="addr">@2</span>.
      Чтобы узнать, куда ссылается <span class="addr">@2</span>, сначала посмотрим на ячейку <span class="addr">$2</span> (это инструкция <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></span>)
      и возьмем ее В-поле.
      В итоге <span class="addr">@2</span> ссылается на четвертую ячейку относительно <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></span>. Если бы вместо этого там было записано <span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#10</span>,
      он бы ссылался на 10 ячейку относительно неё и так далее.
    </div>

    <div>
      Имеем, что команда <span class="code"><span class="command">MOV</span> <span class="addr">$2</span>, <span class="addr">@2</span></span> копирует команду <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></span> в ячейку, находящуюся через три после нашей программы:
    </div>

    <div class="code"><span class="command">ADD</span> <span class="addr">#4</span>, <span class="addr">$3</span></div>
    <div class="code"><span class="command">MOV</span> <span class="addr">$2</span>, <span class="addr">@2</span></div>
    <div class="code"><span class="command">JMP</span> <span class="addr">$-2</span></div>
    <div class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></div>

    <div>
      Следующая инструкция <span class="code"><span class="command">JMP</span> <span class="addr">$-2</span></span>
      имеет только один операнд и означает безусловный переход на ячейку <span class="addr">$-2</span>,
      организуя тем самым вечный цикл из первых трех команд. На следующей итерации в четвертой инструкции программы будет записано уже
      <span class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#8</span></span>, в следствие чего эта команда скопируется в ячейку, находящуюся на расстоянии 8:
    </div>

    <div class="code"><span class="command">ADD</span> <span class="addr">#4</span>, <span class="addr">$3</span></div>
    <div class="code"><span class="command">MOV</span> <span class="addr">$2</span>, <span class="addr">@2</span></div>
    <div class="code"><span class="command">JMP</span> <span class="addr">$-2</span></div>
    <div class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#8</span></div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#4</span></div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code"><span class="command">DAT</span> <span class="addr">#0</span>, <span class="addr">#8</span></div>

    <div>
      Продолжая выполнение, <i>Бомбер</i> будет заполнять каждую четвертую ячейку памяти командой <span class="command">DAT</span>, пытаясь &laquo;попасть&raquo; в противника.
    </div>

    <div>
      После начала соревнования вы можете сравнить поведение <i>Imp</i> и <i>Бомбера</i> в нашем <a href="debugger.html">отладчике</a>.
    </div>

    <h3 id="threads">Потоки выполнения</h3>

    <div>
      Чтобы защитить себя от смерти, программа может создавать новые потоки выполнения,
      которые будут исполняться независимо от главного. В случае смерти любого из потоков остальные продолжают жить
      и выполнять свою задачу. Однако будьте аккуратны &mdash; компьютер по прежнему будет выполнять только одну инструкцию
      вашей программы за такт, независимо от количества потоков.
      Чтобы узнать, какую инструкцию сейчас выполнить, он хранит и поддерживает <b>очередь исполнения</b> вашей программы.
      Изначально в очереди лежит один адрес &mdash; адрес инструкции, с которой нужно начать исполнение вашей программы.
      Перед исполнением очередной команды, компьютер извлекает адрес из очереди и выполняет команду по этому адресу.
      После этого, если не было произведено условного или безусловного перехода, адрес, на единицу больший текущего, добавляется в конец очереди.
      В случае выполнения перехода (условного или безусловного) в очередь попадает адрес, куда был совершен переход.
      Если программа породила новый процесс, то адрес инструкции, с которой начнется выполнение в новом процессе,
      так же добавляется в очередь выполнения.
    </div>

    <div>
      Во время боя каждая программа имеет свою очередь исполнения.
    </div>

    <h3 id="commands">Команды</h3>
    <div>
      В качестве любого из операндов можно использовать арифметическое выражение. Поддерживаются скобки, сложение (+), вычитание (-), умножение (*), целочисленное деление (/), унарные плюс и минус. Значение выражения вычисляется в момент компиляции, и в память в качестве операнда попадает уже вычисленное значение, взятое по модулю 8000. Деление на ноль вызывает ошибку компиляции &laquo;Division by zero&raquo;.
    </div>

    <div>
      Рассмотрим детально все существующие команды:
      <ul>      
        <li>
          <span class="code"><span class="command">DAT</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Выполнение этой команды с любыми операндами приводит к уничтожению текущего потока.
        </li>

        <li>
          <span class="code"><span class="command">MOV</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд А имеет непосредственную адресацию, его значение помещается в В-поле инструкции, на которую ссылается операнд B. В противном случае команда, на которую указывает операнд А копируется в ячейку, указанную операндом В.
        </li>

        <li>
          <span class="code"><span class="command">ADD</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд А имеет непосредственную адресацию, его значение прибавляется к В-полю инструкции, на которую ссылается операнд В. В противном случае А- и В-поля команды, на которую указывает операнд А, прибавляются к соответствующим полям
          команды, на которую ссылается операнд В.
        </li>

        <li>
          <span class="code"><span class="command">SUB</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Действует аналогично команде <span class="command">ADD</span>. 
          Если операнд А имеет непосредственную адресацию, его значение вычитается из В-поля инструкции, на которую ссылается операнд В. В противном случае А- и В-поля команды, на которую указывает операнд А, вычитаются из соответствующих полей
          команды, на которую ссылается операнд В.
        </li>

        <li>
          <span class="code"><span class="command">JMP</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Адрес, на который указывает операнд А, помещается в конец очереди исполнения программы. Операнд В не участвует непосредственно в выполнении команды и может отсутствовать.
        </li>

        <li>
          <span class="code"><span class="command">JMZ</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если В-поле ячейки, на которую указывает операнд В, равно нулю, то происходит переход на адрес, на который ссылается
          операнд А. Это означает, что адрес ячейки для перехода помещается в конец очереди исполнения, а адрес следующей за текущей инструкции не помещается.
        </li>

        <li>
          <span class="code"><span class="command">JMN</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если В-поле ячейки, на которую указывает операнд В, не равно нулю, то происходит переход на адрес, на который ссылается
          операнд А.
        </li>

        <li>
          <span class="code"><span class="command">CMP</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд А имеет непосредственную адресацию, он сравнивается с В-полем команды, на которую указывает операнд В,
          в противном случае сравнивается полное содержимое ячеек, на которые ссылаются операнды А и В. Если сравниваемые значения равны, следующая инструкция пропускается, и управление переходит к инструкции, находящейся через одну.
        </li>

        <li>
          <span class="code"><span class="command">SLT</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд А имеет непосредственную адресацию, он сравнивается с В-полем команды, на которую указывает операнд В,
          в противном случае сравнивается В-поля ячеек, на которые ссылаются операнды А и В. Если значение А меньше, чем значение В, то следующая инструкция пропускается, и управление переходит к инструкции, находящейся через одну.
        </li>

        <li>
          <span class="code"><span class="command">DJN</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд В имеет не непосредственную адресацию, то В-поле ячейки, на которую указывает оператор В, уменьшается на единицу с сохранением результата на прежнем месте, в противном случае то же самое делается с В-полем текущей инструкции.
          Если уменьшенное значение не равно нулю, происходит переход на инструкцию, на которую указывает операнд А.
        </li>

        <li id="command-spl">
          <span class="code"><span class="command">SPL</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Данная команда порождает новый поток выполнения. Первым делом в конец очереди попадает адрес, на который указывает операнд А, после чего туда добавляется адрес следующей инструкции. Если обе команды не поместятся в очередь из-за ограничения на её размер, то новый поток не создается, а в очередь добавляется только адрес следующей инструкции.
          Ограничение на размер очереди &mdash; 1000 адресов. <b>Обратите внимание</b>, что команда <span class="command">SPL</span> работает здесь немного не так, как в оригинальном стандарте.
        </li>
      </ul>        

      <span id="distinction">Важным</span> отличием нашего компьютера от всех подобных заключается в наличии следующих трех команд:

      <ul>
        <li>
          <span class="code"><span class="command">MOV.4</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд А имеет непосредственную адресацию, его значение помещается в В-поля следующих инструкций: той, на которую ссылается операнд B, а также трёх последующих за ней. В противном случае 4 команды, начиная с той, на которую указывает операнд А, копируется в соответствующие 4 ячейки, начинающихся с адреса, указанного операндом В.
          Обратите внимание, что все 4 команды сохраняются во временную память до вычисления адреса B, откуда потом копируются
          в необходимые ячейки.
        </li>

        <li>
          <span class="code"><span class="command">ADD.4</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Если операнд А имеет непосредственную адресацию, его значение прибавляется к В-полям четырёх инструкций, начинающихся с адреса, на который ссылается операнд В. В противном случае А- и В-поля четырёх команд, начинающихся с той, на которую указывает операнд А, прибавляются к соответствующим полям соответствующих четырёх команд, начинающихся с той,
          на которую ссылается операнд В. Обратите внимание, что все 4 команды сохраняются во временную память до вычисления адреса B, откуда потом прибавляются в необходимые ячейки.
        </li>

        <li>
          <span class="code"><span class="command">SUB.4</span> <span class="addr">A</span>, <span class="addr">B</span></span>:
          Действует аналогично <span class="command">ADD.4</span>. Если операнд А имеет непосредственную адресацию, его значение вычитается из В-полей четырёх инструкций, начинающихся с адреса, на который ссылается операнд В. В противном случае А- и В-поля четырёх команд, начинающихся с той, на которую указывает операнд А, вычитаются из соответствующих полей соответствующих четырёх команд, начинающихся с той,
          на которую ссылается операнд В. Обратите внимание, что все 4 команды сохраняются во временную память до вычисления адреса B, откуда потом берутся для вычитания их необходимых ячеек.
        </li>

      </ul>
    </div>

    <div>
      Большинство команд требует двух операндов, однако команды <span class="command">SPL</span> и <span class="command">JMP</span> можно использовать и только с одним. В этом случае не записываются запятая и второй&nbsp;аргумент. 
    </div>    

    <div>
      Любая команда выполняется следующим образом. Первым делом, если А-поле имеет не непосредственную адресацию,
      вычисляется адрес ячейки, куда оно ссылается. Если необходимо, при этом выполняется соответствующий декремент (см.&nbsp;<a href="#addressing-predecrement-indirect">предекрементную косвенную адресацию</a>).
      Содержимое ячейки, ссылку на которую мы получили, запоминается.
    </div>

    <div>
      После этого, аналогичным образом, если В-поле имеет не непосредственную адресацию, вычисляется адрес, на который оно указывает. Это делается даже в том случае, если для текущей команды не нужен второй операнд. Например, команда <span class="code"><span class="command">DAT</span> <span class="addr">&lt;5</span>, <span class="addr">&lt;7</span></span> перед смертью потока успеет уменьшить В-поля двух инструкций. 
    </div>

    <div>
      И только в самом конце выполняется сама инструкция.
      При этом если для исполнения компьютеру необходимо содержимое ячейки, на которую указывает А-поле,
      то используется именно сохраненное значение, так как вычисление указателя в В-поле теоретически могло изменить его. 
    </div>

    <h3>Общая структура программы</h3>
    <div>
      Программа представляет собой набор строк, в каждой из которых либо не находится ни одной команды,
      либо находится ровно одна. В любом месте программы может встречаться комментарий &mdash; любой текст,
      начинающийся с точки с запятой (;). Комментарий длится до конца строки, в которой он начался. 
    </div>

    <div>
      Пустые строки никак не влияют на исполнение программы. В любом месте, где необходим пробел, может стоять любое ненулевое количество пробелов. 
    </div>

    <div>
      Названия команд являются регистронезависимыми, то есть вы можете писать <span class="command">MOV</span>, <span class="command">mov</span> или даже <span class="command">mOv</span>. 
    </div>

    <h3>Метки</h3>
    <div>
      Кроме того, каждая команда может содержать перед собой метку, отделенную от самой команды одним или более пробелами.
      Название метки не может совпадать с названием какой-либо команды (то есть не может быть <span class="command">MOV</span>, <span class="command">ADD</span> и так далее), и должно быть уникальным среди названий всех меток программы. 
    </div>

    <div>      
      Метка команды может использоваться внутри арифметических выражений в А- и В-полях любой команд. Во время компиляции программы в момент вычисления значения выражения имя метки заменяется на смещение строки с этой меткой относительно текущей.
    </div>

    <div>
      Метка должно состоять из букв, цифр, символов точки (.) и подчеркивания (_).      
    </div>

    <div>Действие меток можно увидеть на следующем примере:</div>

    <div class="code">bomb <span class="command">DAT</span> <span class="addr">0,</span> <span class="addr">0</span></div>
    <div class="code">loop <span class="command">ADD</span> <span class="addr">#3039</span>, <span class="addr">ptr</span></div>
    <div class="code">ptr <span class="command">MOV</span> <span class="addr">bomb</span>, <span class="addr">81</span></div>
    <div class="code"><span class="command">JMP</span> <span class="addr">loop</span></div>

    <h3>Дополнительные возможности</h3>
    <div>
      Существует также две структуры языка, которые не являются командами &mdash; это <span class="command">EQU</span> и
      <span class="command">END</span>.

      Первая позволяет создавать умные арифметические макросы подстановки (&laquo;константы&raquo;), которые могут быть использованы внутри
      арифметических выражений в операндах или определении других макросов:
    </div>

    <div class="code">step <span class="command">EQU</span> 123</div>
    <div class="code">big_step <span class="command">EQU</span> 3 * step + 10</div>
    <div class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$big_step + 1</span></div>

    <div>
      Определение макроса может также содержать название какой-нибудь метки, определенной в программе. В этом случае значение 
      макроса будет зависеть от строки, в которой он будет использован. При подстановке макроса, как и в случае обычного использования метка будет заменена на относительное смещение адреса с&nbsp;меткой относительно текущей ячейки: 
    </div>

    <div class="code">dist <span class="command">EQU</span> start + 2</div>
    <div class="code">start ...</div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code">...</div>
    <div class="code"><span class="command">MOV</span> <span class="addr">$0</span> <span class="addr">$dist</span></div>
    <div class="code"><span class="command">MOV</span> <span class="addr">$0</span> <span class="addr">$dist</span></div>

    <div>
      В вышеприведенном примере предпоследняя команда заменится во время компиляции на
      <span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$7998</span></span> (что аналогично <span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$-2</span></span>),
      а последняя &mdash; на&nbsp;<span class="code"><span class="command">MOV</span> <span class="addr">$0</span>, <span class="addr">$7997</span></span>.
    </div>

    <div>
      Название макроса должно быть уникально, должно отличать от названий меток в программе и может состоять только из букв, цифр, символов точки (.) и подчеркивания (_).
    </div>

    <div>
      Как уже было сказано, макрос может использовать в своём определении метки или названия других макросов, однако не может
      образовывать циклическую зависимость макросов друг от друга. Следующий код
    </div>

    <div class="code">a <span class="command">EQU</span> b + 10</div>
    <div class="code">b <span class="command">EQU</span> c + 10</div>
    <div class="code">c <span class="command">EQU</span> a + 5</div>

    <div>вызывает ошибку компиляции <a href="#error-cycle">Cycle in constants evaluation detected</a>.</div>

    <div>Вторая структура языка имеет синтаксис команды, может иметь метку, хотя командой как таковой не является. Это ключевое
    слово <span class="command">END</span>. После себя оно может иметь один параметр (число, метку или макрос, но не арифметическое выражение), либо не иметь параметров вообще (что равносильно одному параметру, равному&nbsp;0). Весь текст программы после строки, содержащей ключевое слово <span class="command">END</span>, игнорируется. Если <span class="command">END</span> имеет параметр, то он используется как номер команды в программе, с которой начнётся выполнение. Команды в программе нумеруются с нуля.</div>

    <h3>Ограничение на размер кода</h3>
    <div>
      Количество команд в программе (напомним, что <span class="command">EQU</span> и <span class="command">END</span> не являются командами) не может быть больше 512.
    </div>

    <h3>Модульная арифметика</h3>
    <div>
      Результаты подсчёта всех арифметических выражений в процессе компиляции и выполнения берутся по модулю 8000. Однако если в качестве операнда какой-нибудь инструкции указано арифметическое выражение, то все операции внутри него будут выполнены в обычной арифметике, и только к результату применена операция взятия остатка от деления на 8000. Например, выражение
      <span class="addr">(-5) / 2</span> будет эквивалентно <span class="addr">7998</span>, так как
      <span class="addr">(-5) / 2</span>&nbsp;<span class="code">=</span>&nbsp;<span class="addr">-2</span>, а
      <span class="addr">-2</span>&nbsp;<span class="code">&equiv;</span>&nbsp;<span class="addr">7998</span>&nbsp;<span class="code">(mod 8000)</span>.
    </div>

    <h3>Как проходит бой двух программ</h3>
    <div>
      Вначале две соревнующиеся программы загружаются в последовательные области памяти на расстоянии друг от друга не менее 512 ячеек. Ходы программ чередуются. На каждом ходе программа исполняет ровно одну команду одного из своих потоков. Если все потоки какой-либо программы умерли (в то или иное время выполнив команду&nbsp;<span class="command">DAT</span>), то это программа объявляется проигравшей, а её соперник, соответственно, выигравшей в этом бою.
    </div>

    <div>
      В случае, если каждая программа сделала по 80&nbsp;000 ходов, а победитель не определился, объявляется ничья.
    </div>

    <h3>Турнир</h3>
    <div>
      Вы можете <a href="submit.html">отправить</a> вашего бота нам. Во время всего соревнования мы будем регулярно проводить
      турниры среди отправленных ботов и поддерживать <a href="ranking.html">рейтинговую таблицу</a>. В турнире участвуют последние версии присланных ботов. Во время турнира между каждой парой ботов проводится несколько раундов, каждый из которых содержит два боя (каждому участнику предоставляется право стартовать первым и стартовать вторым), в результате каждого их которых победитель
      получает <b>3 очка</b>, а проигравший 0. В случае ничьи каждый из ботов получает <b>по одному очку</b>. 
    </div>

    <div>
      Количество раундов для всех пар в рамках одного турнира равно. Количество раундов может меняться от турнира к турниру 
      в зависимости от количества ботов, однако гарантируется, что в каждом турнире каждая пара сыграет хотя бы по одному раунду.
    </div>

    <div>
      После окончания соревнования мы проведём последний, заключительный, турнир, результаты которого и станут окончательными результатами соревнования.
    </div>

    <h3>Константы</h3>
    <table class="table">
      <tr><th>Константа</th><th>Значение</th></tr>
      <tr><td>Размер поля</td><td>8000</td></tr>
      <tr><td>Максимальное количество команд в программе</td><td>512</td></tr>
      <tr><td>Минимальное расстояние между загруженными в память программами</td><td>1024</td></tr>
      <tr><td>Максимальный размер очереди исполнения одной программы</td><td>1000</td></tr>
      <tr><td>Количество ходов, которое сделает программа каждого из участников, после которого наступает ничья</td><td>80&nbsp;000</td></tr>
    </table>

    <h3 id="errors">Сообщения об ошибках</h3>
    <div>
      Сообщение об ошибке можно увидеть при начале отладке или при отправке бота. Любое сообщение содержит строку, в которой была найдена ошибка, а также поясняющее сообщение о типе ошибки. Возможные сообщения приведены в таблице ниже. Если вы не понимаете, почему возникает та или иная ошибка, обратитесь к организаторам. 
    </div>

    <div></div>

    <table class="table">
      <tr><th width=400>Сообщение</th><th>Комментарий</th></tr>
      <tr><td>Unknown label on constant '&lt;name&gt;'</td><td>Попытка использовать метку или макрос &lt;name&gt; в арифметическом выражении, хотя ни такой метки, ни такого макроса определено не было</td></tr>
      <tr><td>Statement with same label '&lt;name&gt;' already exists</td><td>Попытка объявить макрос или команду с меткой, которые имеют такое же имя, как уже существующая команда</td></tr>
      <tr><td>Constant with same label '&lt;name&gt;' already</td><td>Попытка объявить макрос или команду с меткой, которые имеют такое же имя, как уже существующий макрос</td></tr>
      <tr><td>Too long program. Max allowed length is&nbsp;512</td><td>Превышено максимальное количество инструкций в программе</td></tr>
      <tr><td>Not a command</td><td>То, что записано в строке, не является верной командой</td></tr>
      <tr><td>A-Field expected in '&lt;command&gt;'</td><td>У команды не указано А-поле. В качестве &lt;command&gt; может быть название команды или конструкция&nbsp;<span class="command">EQU</span></td></tr>
      <tr><td>B-Field expected in '&lt;command&gt;'</td><td>У команды не указано B-поле, хотя данный тип команд не подразумевает использования с одним операндом</td></tr>
      <tr><td id="error-invalid-addressing-mode">Invalid addressing mode</td><td>Для этой команды не подразумевается такие типы адресаций в операндах</td></tr>
      <tr><td>Expected comma</td><td>Между операндами ожидается запятая</td></tr>
      <tr><td>Can't find close bracket</td><td>В строке не найдена парная закрывающаяся скобка</td></tr>
      <tr><td>Invalid token in expression</td><td>Неизвестный токен или символ в арифметическом выражении</td></tr>
      <tr><td>Unexpected end of line</td><td>Неожиданный конец строки</td></tr>
      <tr><td>Division by zero</td><td>Деление на ноль в выражении</td></tr>
      <tr><td id="error-cycle">Cycle in constants evaluation detected</td><td>Макросы не могут ссылаться друг на друга циклически</td></tr>
      <tr><td>END argument must be label, constant name or number</td><td>Аргумент конструкции <span class="command">END</span> должен быть меткой, названием макроса или числом и не может быть арифметическим выражением</td></tr>
      <tr><td>EQU statement should have label</td><td>Конструкция <span class="command">EQU</span> должна иметь перед собой метку &mdash; название макроса</td></tr>
      <tr><td>Expected end of command</td><td>Ожидался конец команды или служебной инструкции, но были найдены лишние символы</td></tr>
    </table>

    <h3 id="addresses">Возможные адресации всех команд</h3>
    <table class="table table-bordered table-condensed">
      <tr><th class="command">ADD</th><td><span class="code">ADD    A    B </span></td><td><span class="code">ADD    A  @B </span></td><td><span class="code">ADD    A  &lt;B </span></td><td><span class="code">ADD  #A    B </span></td><td><span class="code">ADD  #A  @B </span></td><td><span class="code">ADD  #A  &lt;B </span></td><td><span class="code">ADD  @A    B </span></td><td><span class="code">ADD  @A  @B </span></td><td><span class="code">ADD  @A  &lt;B </span></td><td><span class="code">ADD  &lt;A    B </span></td><td><span class="code">ADD  &lt;A  @B </span></td><td><span class="code">ADD  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">CMP</th><td><span class="code">CMP    A    B </span></td><td><span class="code">CMP    A  @B </span></td><td><span class="code">CMP    A  &lt;B </span></td><td><span class="code">CMP  #A    B </span></td><td><span class="code">CMP  #A  @B </span></td><td><span class="code">CMP  #A  &lt;B </span></td><td><span class="code">CMP  @A    B </span></td><td><span class="code">CMP  @A  @B </span></td><td><span class="code">CMP  @A  &lt;B </span></td><td><span class="code">CMP  &lt;A    B </span></td><td><span class="code">CMP  &lt;A  @B </span></td><td><span class="code">CMP  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">DJN</th><td><span class="code">DJN    A    B </span></td><td><span class="code">DJN    A  #B </span></td><td><span class="code">DJN    A  @B </span></td><td><span class="code">DJN    A  &lt;B </span></td><td><span class="code">DJN  @A    B </span></td><td><span class="code">DJN  @A  #B </span></td><td><span class="code">DJN  @A  @B </span></td><td><span class="code">DJN  @A  &lt;B </span></td><td><span class="code">DJN  &lt;A    B </span></td><td><span class="code">DJN  &lt;A  #B </span></td><td><span class="code">DJN  &lt;A  @B </span></td><td><span class="code">DJN  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">JMN</th><td><span class="code">JMN    A    B </span></td><td><span class="code">JMN    A  #B </span></td><td><span class="code">JMN    A  @B </span></td><td><span class="code">JMN    A  &lt;B </span></td><td><span class="code">JMN  @A    B </span></td><td><span class="code">JMN  @A  #B </span></td><td><span class="code">JMN  @A  @B </span></td><td><span class="code">JMN  @A  &lt;B </span></td><td><span class="code">JMN  &lt;A    B </span></td><td><span class="code">JMN  &lt;A  #B </span></td><td><span class="code">JMN  &lt;A  @B </span></td><td><span class="code">JMN  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">JMP</th><td><span class="code">JMP    A    B </span></td><td><span class="code">JMP    A  #B </span></td><td><span class="code">JMP    A  @B </span></td><td><span class="code">JMP    A  &lt;B </span></td><td><span class="code">JMP  @A    B </span></td><td><span class="code">JMP  @A  #B </span></td><td><span class="code">JMP  @A  @B </span></td><td><span class="code">JMP  @A  &lt;B </span></td><td><span class="code">JMP  &lt;A    B </span></td><td><span class="code">JMP  &lt;A  #B </span></td><td><span class="code">JMP  &lt;A  @B </span></td><td><span class="code">JMP  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">JMZ</th><td><span class="code">JMZ    A    B </span></td><td><span class="code">JMZ    A  #B </span></td><td><span class="code">JMZ    A  @B </span></td><td><span class="code">JMZ    A  &lt;B </span></td><td><span class="code">JMZ  @A    B </span></td><td><span class="code">JMZ  @A  #B </span></td><td><span class="code">JMZ  @A  @B </span></td><td><span class="code">JMZ  @A  &lt;B </span></td><td><span class="code">JMZ  &lt;A    B </span></td><td><span class="code">JMZ  &lt;A  #B </span></td><td><span class="code">JMZ  &lt;A  @B </span></td><td><span class="code">JMZ  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">MOV</th><td><span class="code">MOV    A    B </span></td><td><span class="code">MOV    A  @B </span></td><td><span class="code">MOV    A  &lt;B </span></td><td><span class="code">MOV  #A    B </span></td><td><span class="code">MOV  #A  @B </span></td><td><span class="code">MOV  #A  &lt;B </span></td><td><span class="code">MOV  @A    B </span></td><td><span class="code">MOV  @A  @B </span></td><td><span class="code">MOV  @A  &lt;B </span></td><td><span class="code">MOV  &lt;A    B </span></td><td><span class="code">MOV  &lt;A  @B </span></td><td><span class="code">MOV  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">SLT</th><td><span class="code">SLT    A    B </span></td><td><span class="code">SLT    A  @B </span></td><td><span class="code">SLT    A  &lt;B </span></td><td><span class="code">SLT  #A    B </span></td><td><span class="code">SLT  #A  @B </span></td><td><span class="code">SLT  #A  &lt;B </span></td><td><span class="code">SLT  @A    B </span></td><td><span class="code">SLT  @A  @B </span></td><td><span class="code">SLT  @A  &lt;B </span></td><td><span class="code">SLT  &lt;A    B </span></td><td><span class="code">SLT  &lt;A  @B </span></td><td><span class="code">SLT  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">SPL</th><td><span class="code">SPL    A    B </span></td><td><span class="code">SPL    A  #B </span></td><td><span class="code">SPL    A  @B </span></td><td><span class="code">SPL    A  &lt;B </span></td><td><span class="code">SPL  @A    B </span></td><td><span class="code">SPL  @A  #B </span></td><td><span class="code">SPL  @A  @B </span></td><td><span class="code">SPL  @A  &lt;B </span></td><td><span class="code">SPL  &lt;A    B </span></td><td><span class="code">SPL  &lt;A  #B </span></td><td><span class="code">SPL  &lt;A  @B </span></td><td><span class="code">SPL  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">SUB</th><td><span class="code">SUB    A    B </span></td><td><span class="code">SUB    A  @B </span></td><td><span class="code">SUB    A  &lt;B </span></td><td><span class="code">SUB  #A    B </span></td><td><span class="code">SUB  #A  @B </span></td><td><span class="code">SUB  #A  &lt;B </span></td><td><span class="code">SUB  @A    B </span></td><td><span class="code">SUB  @A  @B </span></td><td><span class="code">SUB  @A  &lt;B </span></td><td><span class="code">SUB  &lt;A    B </span></td><td><span class="code">SUB  &lt;A  @B </span></td><td><span class="code">SUB  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">DAT</th><td><span class="code">DAT  #A  #B </span></td><td><span class="code">DAT  #A  &lt;B </span></td><td><span class="code">DAT  &lt;A  #B </span></td><td><span class="code">DAT  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">MOV.4</th><td><span class="code">MOV.4    A    B </span></td><td><span class="code">MOV.4    A  @B </span></td><td><span class="code">MOV.4    A  &lt;B </span></td><td><span class="code">MOV.4  #A    B </span></td><td><span class="code">MOV.4  #A  @B </span></td><td><span class="code">MOV.4  #A  &lt;B </span></td><td><span class="code">MOV.4  @A    B </span></td><td><span class="code">MOV.4  @A  @B </span></td><td><span class="code">MOV.4  @A  &lt;B </span></td><td><span class="code">MOV.4  &lt;A    B </span></td><td><span class="code">MOV.4  &lt;A  @B </span></td><td><span class="code">MOV.4  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">ADD.4</th><td><span class="code">ADD.4    A    B </span></td><td><span class="code">ADD.4    A  @B </span></td><td><span class="code">ADD.4    A  &lt;B </span></td><td><span class="code">ADD.4  #A    B </span></td><td><span class="code">ADD.4  #A  @B </span></td><td><span class="code">ADD.4  #A  &lt;B </span></td><td><span class="code">ADD.4  @A    B </span></td><td><span class="code">ADD.4  @A  @B </span></td><td><span class="code">ADD.4  @A  &lt;B </span></td><td><span class="code">ADD.4  &lt;A    B </span></td><td><span class="code">ADD.4  &lt;A  @B </span></td><td><span class="code">ADD.4  &lt;A  &lt;B </span></td></tr>
      <tr><th class="command">SUB.4</th><td><span class="code">SUB.4    A    B </span></td><td><span class="code">SUB.4    A  @B </span></td><td><span class="code">SUB.4    A  &lt;B </span></td><td><span class="code">SUB.4  #A    B </span></td><td><span class="code">SUB.4  #A  @B </span></td><td><span class="code">SUB.4  #A  &lt;B </span></td><td><span class="code">SUB.4  @A    B </span></td><td><span class="code">SUB.4  @A  @B </span></td><td><span class="code">SUB.4  @A  &lt;B </span></td><td><span class="code">SUB.4  &lt;A    B </span></td><td><span class="code">SUB.4  &lt;A  @B </span></td><td><span class="code">SUB.4  &lt;A  &lt;B </span></td></tr>                  
    </table>
    </div>

	</div>
</body>
</html>
